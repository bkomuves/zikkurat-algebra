
-- | Multi-Scalar Multiplication

{-# LANGUAGE StrictData, RecordWildCards #-}
module Zikkurat.CodeGen.Curve.MSM where

--------------------------------------------------------------------------------

import Data.List
import Data.Word
import Data.Bits

import Control.Monad
import System.FilePath

import Zikkurat.CodeGen.Misc
--import Zikkurat.Primes -- ( integerLog2 )

import Zikkurat.CodeGen.Curve.Params
import Zikkurat.CodeGen.Curve.CurveFFI

--------------------------------------------------------------------------------

msm_c_header :: Curve -> CodeGenParams -> Code
msm_c_header (Curve{..}) (CodeGenParams{..}) =
  [ "extern void " ++ prefix ++ "MSM_std_coeff_"  ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_std_coeff_affine_out (int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_mont_coeff_affine_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  , "extern void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "c_out_slow_reference(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs);"
  ]

msm_hs_binding :: Curve -> CodeGenParams -> Code
msm_hs_binding (Curve{..}) (CodeGenParams{..}) =
  [ ""
  , "foreign import ccall unsafe \"" ++ prefix ++ "MSM_std_coeff_"  ++ point_repr ++ "_out\" c_" ++ prefix ++ "MSM_std_coeff_"  ++ point_repr ++ "_out :: CInt -> Ptr Word64 -> Ptr Word64 -> Ptr Word64 -> CInt -> IO ()"
  , "foreign import ccall unsafe \"" ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out\" c_" ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out :: CInt -> Ptr Word64 -> Ptr Word64 -> Ptr Word64 -> CInt -> IO ()"
  , ""
  , "{-# NOINLINE msm #-}"
  , "-- | Multi-Scalar Multiplication (MSM), with the coefficients in Montgomery representation,"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > msmStd :: FlatArray Fr -> FlatArray Affine.G1 -> G1"
  , "-- "
  , "msm :: FlatArray Fr -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> " ++ typeName
  , "msm (MkFlatArray n1 fptr1) (MkFlatArray n2 fptr2)"
  , "  | n1 /= n2   = error \"msm: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray " ++ show (3*nlimbs_p)
  , "      withForeignPtr fptr1 $ \\ptr1 -> do"
  , "        withForeignPtr fptr2 $ \\ptr2 -> do"
  , "          withForeignPtr fptr3 $ \\ptr3 -> do"
  , "            c_" ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out (fromIntegral n1) ptr1 ptr2 ptr3 " ++ show nlimbs_r
  , "      return (Mk" ++ typeName ++ " fptr3)"
  , ""
  , "{-# NOINLINE msmStd #-}"
  , "-- | Multi-Scalar Multiplication (MSM), with the coefficients in standard representation,"
  , "-- and the curve points in affine coordinates"
  , "-- "
  , "-- > msmStd :: FlatArray Std.Fr -> FlatArray Affine.G1 -> G1"
  , "-- "
  , "msmStd :: FlatArray " ++ hsModule hs_path_r_std ++ ".Fr -> FlatArray " ++ hsModule hs_path_affine ++ "." ++ typeName ++ " -> " ++ typeName
  , "msmStd (MkFlatArray n1 fptr1) (MkFlatArray n2 fptr2)" 
  , "  | n1 /= n2   = error \"msm: incompatible array dimensions\""
  , "  | otherwise  = unsafePerformIO $ do"
  , "      fptr3 <- mallocForeignPtrArray " ++ show (3*nlimbs_p)
  , "      withForeignPtr fptr1 $ \\ptr1 -> do"
  , "        withForeignPtr fptr2 $ \\ptr2 -> do"
  , "          withForeignPtr fptr3 $ \\ptr3 -> do"
  , "            c_" ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out (fromIntegral n1) ptr1 ptr2 ptr3 " ++ show nlimbs_r
  , "      return (Mk" ++ typeName ++ " fptr3)"
  , ""
  ]


msmCurve :: Curve -> CodeGenParams -> Code
msmCurve (Curve{..}) (CodeGenParams{..}) =
  [ "//------------------------------------------------------------------------------"
  , ""
  , "#define SIDX(b) (SUMS + (b-1)*(3*NLIMBS_P))"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// standard coefficients (NOT montgomery!)"
  , "// straightforward Pippenger bucketing method"
  , "// parametric bucket size"
  , "void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out_variable(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs, int window_size) {"
  , ""
  , "  assert( (window_size > 0) && (window_size <= 64) );"
  , ""
  , "  int nwindows = (64*expo_nlimbs + window_size - 1) / window_size;"
  , "  int nbuckets = (1 << window_size);"
  , ""
  , "  " ++ prefix ++ "set_infinity(tgt);"
  , ""
  , "  // allocate memory for bucket sums"
  , "  uint64_t *SUMS = malloc( 3*8*NLIMBS_P * (nbuckets-1) );"
  , "  assert( SUMS !=0 );"
  , ""
  , "  // loop over the windows"
  , "  for(int K=nwindows-1; K >= 0; K-- ) {"
  , ""
  , "    // K-th window"
  , "    int A = K*window_size;"
  , "    int B = A + window_size;"
  , "    if (B > 64*expo_nlimbs ) { B = 64*expo_nlimbs; }"
  , ""
  , "    uint64_t mask = (1<<(B-A)) - 1;"
  , ""
  , "    int Adiv = (A >> 6);    // A / 64"
  , "    int Amod = (A & 0x3f);  // A mod 64"
  , ""
  , "    int Bdiv = Adiv;"
  , "    int Bshl = 0;"
  , "    if (((B-1)>>6) != Adiv) { "
  , "      // the window intersects qword boundary..."
  , "      Bdiv = Adiv + 1; "
  , "      Bshl = 64*Bdiv - A; "
  , "    }"
  , ""
  , "    // we could do this in constant memory, but then would have "
  , "    // to we go over the points way many (=bucket_size) times..."
  , ""
  , "    // initalize bucket sums"
  , "    for( int b=nbuckets-1; b>0; b-- ) { "
  , "      " ++ prefix ++ "set_infinity( SIDX(b) );"
  , "    }"
  , ""
  , "    // compute bucket sums"
  , "    for(int j=0; j<npoints; j++) {"
  , ""
  , "      int ofs = expo_nlimbs*j + Adiv;"
  , "      uint64_t e = (expos[ofs] >> Amod);"
  , "      if (Bdiv != Adiv) {"
  , "        e |= (expos[ofs+1] << Bshl);"
  , "      }"
  , "      e &= mask;   // bucket coeff"
  , ""
  , "      if (e>0) {"
  , "        " ++ prefix ++ "madd_" ++ point_repr ++ "_aff( SIDX(e) , grps + (2*NLIMBS_P*j) , SIDX(e) );"
  , "      }"
  , "    }"
  , ""
  , "    // compute running sums"
  , ""
  , "    uint64_t T[3*NLIMBS_P];   // cumulative sum of S-es"
  , "    uint64_t R[3*NLIMBS_P];   // running sum = sum of T-s"
  , ""
  , "    " ++ prefix ++ "set_infinity(T);"
  , "    " ++ prefix ++ "set_infinity(R);"
  , ""
  , "    for( int b=nbuckets-1; b>0; b-- ) { "
  , "      " ++ prefix ++ "add_inplace( T , SIDX(b) );"
  , "      " ++ prefix ++ "add_inplace( R , T       );"
  , "    }"
  , ""
  , "    if (!" ++ prefix ++ "is_infinity(tgt)) {    // we can skip doubling when infinity"
  , "      for(int i=0; i<window_size; i++) {"
  , "        " ++ prefix ++ "dbl_inplace(tgt);"
  , "      }"
  , "    }"
  , ""
  , "    " ++ prefix ++ "add_inplace( tgt, R );"
  , "  }"
  , ""
  , "  free(SUMS);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - standard coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - weighted projective Montgomery point"
  , "void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , ""
  , "  // guess optimal window size"
  , "  int c = round( log2(npoints) - 3.5 );"
  , "  if (c < 1 ) { c = 1;  }"
  , "  if (c > 64) { c = 64; }"
  , ""
  , "  " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out_variable(npoints, expos, grps, tgt, expo_nlimbs, c);  "
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// reference (slow) implementation of MSM"
  , "// for testing purposes"
  , "void " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out_slow_reference(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t grp[3*NLIMBS_P];"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "set_infinity( tgt );"
  , "  for(int i=0; i<npoints; i++) { "
  , "    " ++ prefix ++ "from_affine( grps  + i*2*NLIMBS_P , grp );                      // convert to proj coords"
  , "    " ++ prefix ++ "scl_generic( expos + i*expo_nlimbs , grp , tmp , expo_nlimbs );     // exponentiate"
  , "    " ++ prefix ++ "add_inplace( tgt , tmp );                                     // add to the running sum"
  , "  }"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - Montgomery coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - weighted projective Montgomery point"
  , "void " ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t *std_expos = malloc(8*NLIMBS_P*npoints);"
  , "  assert( std_expos != 0);"
  , "  const uint64_t *p;"
  , "  uint64_t *q;"
  , "  p = expos;"
  , "  q = std_expos;"
  , "  for(int i=0; i<npoints; i++) {"
  , "    " ++ prefix_r ++ "to_std( p , q );"
  , "    p += NLIMBS_P;"
  , "    q += NLIMBS_P;"
  , "  }"
  , "  " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out(npoints, std_expos, grps, tgt, expo_nlimbs);"
  , "  free(std_expos);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - standard coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - affine Montgomery point"
  , "void " ++ prefix ++ "MSM_std_coeff_affine_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "MSM_std_coeff_" ++ point_repr ++ "_out(npoints, expos, grps, tmp, expo_nlimbs);"
  , "  " ++ prefix ++ "to_affine(tmp, tgt);"
  , "}"
  , ""
  , "// Multi-Scalar Multiplication (MSM)"
  , "// inputs: "
  , "//  - Montgomery coefficients (1 field element per point)"
  , "//  - affine Montgomery points (2 field elements per point)"
  , "// output:"
  , "//  - affine Montgomery point"
  , "void " ++ prefix ++ "MSM_mont_coeff_affine_out(int npoints, const uint64_t *expos, const uint64_t *grps, uint64_t *tgt, int expo_nlimbs) {"
  , "  uint64_t tmp[3*NLIMBS_P];"
  , "  " ++ prefix ++ "MSM_mont_coeff_" ++ point_repr ++ "_out(npoints, expos, grps, tmp, expo_nlimbs);"
  , "  " ++ prefix ++ "to_affine(tmp, tgt);"
  , "}"
  , ""
  , "//------------------------------------------------------------------------------"
  ]

